# BookKeeper

Приложение для управления книгами с использованием Google Books API и Firebase.

## Настройка проекта

### 1. Настройка Firebase

1. **Создание проекта Firebase**:
   - Перейдите на [Firebase Console](https://console.firebase.google.com/)
   - Создайте новый проект или выберите существующий
   - Добавьте Android-приложение с пакетом `com.xdearboy.bookkeeper`
   - Скачайте файл `google-services.json` и поместите его в директорию `app/`

2. **Настройка Firestore**:
   - В Firebase Console перейдите в раздел "Firestore Database"
   - Нажмите "Создать базу данных"
   - Выберите режим "Test" для разработки или "Production" для продакшена
   - Выберите ближайший регион (например, europe-west3)
   - Нажмите "Создать"
   - Дождитесь создания базы данных (это может занять несколько минут)

3. **Настройка Firebase Authentication**:
   - В Firebase Console перейдите в раздел "Authentication"
   - Во вкладке "Sign-in method" включите метод "Email/Password"
   - Сохраните изменения

4. **Настройка Firebase Storage** (опционально):
   - В Firebase Console перейдите в раздел "Storage"
   - Нажмите "Начать"
   - Выберите режим "Test" для разработки или настройте правила безопасности
   - Выберите ближайший регион
   - Нажмите "Создать"

### 2. Настройка Google Books API

1. **Создание проекта Google Cloud**:
   - Перейдите на [Google Cloud Console](https://console.cloud.google.com/)
   - Создайте новый проект или выберите существующий

2. **Включение Google Books API**:
   - В меню слева выберите "APIs & Services" > "Library"
   - Найдите "Books API" и нажмите на него
   - Нажмите "Enable"

3. **Создание API ключа**:
   - В меню слева выберите "APIs & Services" > "Credentials"
   - Нажмите "Create Credentials" > "API key"
   - Скопируйте созданный ключ

4. **Добавление API ключа в приложение**:
   - Откройте файл `app/src/main/java/com/xdearboy/bookkeeper/util/Constants.java`
   - Вставьте ваш API ключ в переменную `GOOGLE_BOOKS_API_KEY`

## Запуск приложения

1. Откройте проект в Android Studio
2. Синхронизируйте проект с Gradle
3. Запустите приложение на эмуляторе или реальном устройстве

## Устранение проблем

### Ошибка 400 при запросах к Google Books API

Если вы видите ошибки "API error: 400" в логах, проверьте:
- Правильность API ключа в `Constants.java`
- Наличие квоты запросов (по умолчанию 1000 запросов в день)
- Корректность запросов (URL-кодирование специальных символов)

### Ошибки Firebase

Если вы видите ошибки Firebase в логах:
- Убедитесь, что файл `google-services.json` актуален и находится в правильной директории
- Проверьте, что Firestore Database создана и активирована
- Проверьте правила безопасности Firestore и Storage

### Ошибка "The database (default) does not exist"

Если вы видите ошибку "The database (default) does not exist for project":
- Перейдите по ссылке из лога для создания базы данных Firestore
- Дождитесь полной активации базы данных (может занять несколько минут)
- Перезапустите приложение

## Настройка правил безопасности Firestore

Для корректной работы приложения необходимо настроить правила безопасности Firestore. Выполните следующие действия:

1. Откройте [консоль Firebase](https://console.firebase.google.com/)
2. Выберите ваш проект
3. Перейдите в раздел "Firestore Database" в боковом меню
4. Перейдите на вкладку "Правила"
5. Замените текущие правила следующими:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Разрешить доступ к коллекции users только аутентифицированным пользователям
    match /users/{userId} {
      // Разрешить чтение и запись только владельцу документа
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Разрешить доступ к коллекции books для аутентифицированных пользователей
    match /books/{bookId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.resource.data.userId == request.auth.uid;
    }
    
    // Разрешить доступ к остальным коллекциям для всех аутентифицированных пользователей
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

6. Нажмите кнопку "Опубликовать"

## Проверка и исправление настроек базы данных

Если у вас возникает ошибка "Missing or insufficient permissions", необходимо:

1. Убедиться, что база данных Firestore создана:
   - Перейдите в [консоль Firebase](https://console.firebase.google.com/)
   - Выберите ваш проект
   - Перейдите в раздел "Firestore Database"
   - Если база данных не создана, нажмите "Создать базу данных"
   - Выберите режим "test" для начала разработки
   - Выберите ближайший регион размещения

2. Проверьте, что пользователь действительно аутентифицирован в Firebase Authentication:
   - В консоли Firebase перейдите в раздел "Authentication"
   - Убедитесь, что email/password аутентификация включена
   - Проверьте, что пользователь успешно зарегистрирован

## Устранение проблем с Google Play Services и Phenotype API

### Ошибки Google Play Services

В логах могут появляться ошибки, связанные с Google Play Services, такие как "Unknown calling package name 'com.google.android.gms'". Для их устранения:

1. **На реальном устройстве**:
   - Убедитесь, что на устройстве установлены последние версии Google Play Services
   - Откройте "Настройки" > "Приложения" > "Google Play Services"
   - Очистите кеш и данные
   - Перезагрузите устройство

2. **На эмуляторе**:
   - Используйте образ с Google Play Services
   - Обновите Google Play Services через Google Play Store
   - Перезагрузите эмулятор

3. **В приложении**:
   - В `BookKeeperApplication` реализована проверка доступности Google Play Services
   - Если сервисы недоступны, приложение автоматически переключается на локальную аутентификацию
   - В логах будет отображаться текущий статус доступности Google Play Services

### Ошибки Phenotype API

Ошибки Phenotype API ("Failed to register ...", "API: Phenotype.API is not available on this device") могут появляться в логах, но они не влияют на работу приложения:

1. **Для отладки**:
   - Эти ошибки можно игнорировать, они связаны с внутренними процессами Google Play Services
   - В release-версии приложения эти ошибки не будут видны в логах

2. **В производственной среде**:
   - В приложении настроен перехват и игнорирование ошибок Phenotype API
   - Для пользователей эти ошибки не приведут к каким-либо проблемам в работе приложения

3. **Дополнительно**:
   - Если ошибки критически влияют на отладку, можно полностью отключить логирование Google Play Services:
     ```
     adb shell setprop log.tag.GoogleApiAvailability SILENT
     adb shell setprop log.tag.PhenotypeApiService SILENT
     ``` 

## Решение проблемы с многократной инициализацией MainActivity

При работе с приложением могут возникать ситуации, когда `MainActivity` инициализируется несколько раз подряд. Это может вызывать следующие проблемы:

1. Повторное создание интерфейса и фрагментов
2. Дублирование логов инициализации в консоли
3. Лишние сетевые запросы или запросы к базе данных
4. Общее снижение производительности приложения

### Причины проблемы

Основные причины многократной инициализации:

- Быстрое изменение конфигурации устройства (повороты экрана)
- Изменение размера или формата экрана
- Особенности работы вашего устройства (некоторые производители модифицируют Android)
- Сбои в системе Android при обработке жизненного цикла активности

### Реализованное решение

Для решения этой проблемы в `MainActivity` были внесены следующие изменения:

1. **Многоуровневая защита от повторной инициализации**:
   - Добавлен статический флаг `isFirstInit` для отслеживания первого запуска активности
   - Добавлен счетчик инициализаций `initCounter` для предотвращения многократных запусков
   - Сохранён флаг `isInitialized` для текущего экземпляра активности
   
2. **Проверки на разных этапах жизненного цикла**:
   - В методе `onCreate()` проверяется счетчик инициализаций и если он больше 1, активность не инициализируется повторно
   - Флаг инициализации устанавливается в начале метода `onCreate()`, до выполнения логики инициализации
   - В методе `onStart()` сбрасывается счетчик инициализаций для нормального функционирования жизненного цикла

3. **Обработка изменений конфигурации**:
   - В манифесте добавлен атрибут `android:configChanges="orientation|screenSize|screenLayout|keyboardHidden"` для предотвращения пересоздания активности
   - Добавлен метод `onConfigurationChanged()` для корректной обработки изменений конфигурации

4. **Улучшенное логирование**:
   - Добавлены подробные логи для отслеживания попыток повторной инициализации
   - Различаются первая и повторные инициализации для отладки

### Дополнительные меры

Для полного решения проблемы рекомендуется также:

1. Использовать `android:configChanges="orientation|screenSize"` в манифесте для `MainActivity`
2. Проверять состояние авторизации пользователя в методе `onResume()`
3. Использовать `ViewModel` для хранения данных, не зависящих от жизненного цикла активности
4. Рассмотреть возможность применения шаблона Single Activity с различными фрагментами

### Диагностика проблемы

Если вы видите в логах многократное повторение строк инициализации `MainActivity`:

```
MainActivity: Инициализация MainActivity
MainActivity: Toolbar настроен успешно
MainActivity: Пользователь авторизован, настраиваем интерфейс
MainActivity: Навигация успешно настроена
```

То это указывает на описанную выше проблему. Внесенные изменения должны устранить эти повторяющиеся инициализации. 

## Решение проблемы с LiveData и фоновыми потоками

При работе с LiveData важно помнить, что метод `setValue()` может быть вызван только из основного (UI) потока. Попытка вызвать его из фонового потока приведет к исключению:

```
java.lang.IllegalStateException: Cannot invoke setValue on a background thread
```

### Причина проблемы

В приложении возникала ошибка при синхронизации книг с Firebase. Основная причина:

1. Метод `syncUserBooks` в `FirebaseRepository` использовал `setValue()` для обновления `LiveData`
2. Этот метод вызывался из фонового потока внутри `AppDatabase.databaseWriteExecutor.execute()`
3. Как результат - приложение аварийно завершалось с указанной выше ошибкой

### Реализованное решение

Для решения этой проблемы были внесены следующие изменения:

1. **В классе `FirebaseRepository`**:
   - Заменены все вызовы `setValue()` на `postValue()` в методе `syncUserBooks`
   - Добавлена дополнительная обработка исключений
   - Улучшена логика обработки ошибок при работе с Firebase

2. **В классе `BookRepository`**:
   - Добавлен `Handler` для возврата в основной поток перед началом работы с LiveData
   - Улучшена система управления Observer для предотвращения утечек памяти
   - Оптимизирован жизненный цикл Observer: удаление после SUCCESS или ERROR
   - Добавлена обработка исключений

### Рекомендации по работе с LiveData

При работе с LiveData следуйте этим рекомендациям:

1. Используйте `postValue()` вместо `setValue()` если работаете из фонового потока
2. Всегда удаляйте Observer после завершения работы с LiveData
3. Используйте блоки try-catch для обработки возможных исключений
4. Не допускайте зацикливания или повторного использования одного и того же Observer
5. При работе с базой данных возвращайтесь в основной поток перед обновлением UI

### Диагностика проблемы

Если в логах появляется исключение:

```
java.lang.IllegalStateException: Cannot invoke setValue on a background thread
```

Выполните следующие шаги:

1. Найдите стек вызовов, чтобы определить, где именно происходит ошибка
2. Замените все вызовы `setValue()` на `postValue()` в соответствующих методах
3. При необходимости, обеспечьте выполнение кода в основном потоке с помощью `Handler(Looper.getMainLooper()).post()`
4. Проверьте корректность жизненного цикла Observer для LiveData 